{"cells":[{"metadata":{"_uuid":"8e6db4c3ad3b50c17088f1e190a0775ab0909caa","_cell_guid":"7e6bb999-ec91-4273-bda6-b04cf1664186"},"cell_type":"markdown","source":"# Introduction\n____\n\n> **Manipulating** here means moving the same data into different arrangements without changing the actual values. \n\nYou can't do data science without data! Unfortunately, data isn't always in the exact format you want when you get it. In order to ask meaningful questions about data, you will often need to re-arrange data in your dataframe. In this tutorial, you'll learn how to do these things in a fast way that's easy to repeat using a set of software tools known as the \"Tidyverse\".\n\n> The [Tidyverse](https://www.tidyverse.org/), a collection of R packages built around the foundational idea that data in a table should have one variable per column, one observation per row and only one value per cell. \n\nOne of the packages in the Tidyverse is **dplyr**, which is a package for getting at parts of your data in a fast, easy-to-understand way that's easy to replicate. In this tutorial, we're going to learn about and practice using the six core \"verbs\" of data manipulation in the Tidyverse. Together, these will give you the vocabulary you need to quickly interact with data. (If you're curious, the book R for Data Science goes into much more detail, and is available for free on-line [here](http://r4ds.had.co.nz).)\n\n_____________________\n### What will I learn?\n\nBy time you finish this tutorial, you will be able to take a data frame and:\n\n* Use the pipe (**%>%**) to create a seamless workflow \n* Use **select()** to select one or more columns\n* Use **filter()** to select one or more rows\n* Use **mutate()** to add new variables\n* Use **arrange()** to change the order of rows\n* Use **summarize()** to convert a variable to a single value\n* Use **group_by()** to group sets of observations \n\n### What do I need to know before I get started?\n\nYou may find some of the discussion here hard to understand if you don't have a basic familiar with the R language before you begin. I would recommend [this series of lessons](https://www.kaggle.com/rtatman/getting-started-in-r-first-steps/) if you've never used R or never programmed before.\n\n### What will I need to do?\n\nAs you work through this tutorial, you'll have a number of exercise to complete. You are of course free to fork this notebook and do them here, but the easiest option is to fork a version of [this workbook for this lesson](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and do the exercises there."},{"metadata":{"_uuid":"778d9c62fd6ec4b86a8c2afbbd2d026653986843","_cell_guid":"c4b96dd0-f225-41b7-aff5-b889bdef9432"},"cell_type":"markdown","source":" # Table of Contents\n\n* [Get our workspace ready](#Get-our-workspace-ready)\n* [Piping hot data analysis: Using pipes in your analysis](#-Piping-hot-data-analysis:-Using-pipes-in-your-analysis)\n* [Selecting specific columns](#Selecting-specific-columns)\n* [Get specific rows with filter](#Get-Specific-Rows-With-Filter)\n* [Add new variables with mutate](#Add-New-Variables-With-Mutate)\n* [Reorder data with arrange](#Reorder-Data-With-Arrange)\n* [Summarize variables with summarize](#Summarize-variables-with-summarize)\n* [Analyze groups with group_by](#Analyze-groups-with-group_by)"},{"metadata":{"_uuid":"32b00ac87b58e40b5ed8fb7e908498cbcaf86a4c","_cell_guid":"71c34304-e768-4850-99fd-691d95cb776e"},"cell_type":"markdown","source":"# Get our workspace ready\n____\nThis will be pretty quick: we just need to read in the library we're going to use (tidyverse), then read in our data and put it in a data frame. We're going to read our data in using the read_csv() function rather than read.csv(), which will put it in a **tibble**.\n\n> **Tibble:** A \"[modern take on data frames](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html)\", it's bascially a data frame that is designed to be more user-friendly and avoid some of the defaults that lead to frequent bugs.\n\nFor this tutorial, we're going to use an agricultural survey dataset that has information on more than 9500 families. It's not a huge dataset in terms of what you might encounter in industry, but it is large enough that interacting with it in a spreadsheet program would be a pain."},{"metadata":{"scrolled":true,"_kg_hide-output":true,"_uuid":"fb044ceeeb833058635def929959de2bc0067ce2","trusted":false,"_cell_guid":"aae2fae6-ea47-4383-bb13-091abb5ec869"},"cell_type":"code","source":"# library we're going to use\nlibrary(tidyverse)\n\n# read in that data\nfarmData <- read_csv(\"../input/data.csv\")","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"d9e6b8b07c70423f3b5cc15e4786ab886d5b9726","_cell_guid":"e02115ac-6be0-479c-9a4f-f81f42777f62"},"cell_type":"markdown","source":"Now that we've got our data frame read into R, let's take a peek at the first few rows."},{"metadata":{"_uuid":"6ebdc1c02f7a38687b95844845bb3915d03107c3","trusted":false,"_cell_guid":"085f450c-6dab-4ccf-b981-1520a5e88176"},"cell_type":"code","source":"# print the first ten rows of our dataframe\nhead(farmData, 10)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"09f535f6234a3837bf54ec80614ece96726c809b","_cell_guid":"a48a383f-a453-4758-a9fa-720903e302d2"},"cell_type":"markdown","source":"Hmm, this dataset looks super wide. (You can tell because some number of the middle columns have been replaced by ellipses, those three dots.) How big is this dataset?"},{"metadata":{"_uuid":"375e47f092857a81ada2b2b8d2fbc6213ad2fb62","trusted":false,"_cell_guid":"e7927d0e-d3a4-4ca6-aa9f-58cfbf521088"},"cell_type":"code","source":"# get the number of rows and columns in our dataset\ndim(farmData)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"70fe49203ab1c7fecf2a70999a38ef0a209d4745","_cell_guid":"73ef3aca-cb49-4428-a369-6a7798c2f48e"},"cell_type":"markdown","source":"As advertised, it has more than 9500 rows... but it also has more than 1700 columns! This is a big, gnarly dataset. Don't panic, though: we're going to learn how to use data manipulation tools to work with this data without losing our minds. First, however, you're going to need to set up the R environment in your workbook.\n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 1: Getting your workspace ready.\n\n____"},{"metadata":{"_uuid":"fdf4a23fc4a78b2735c2e5bab5e15bc25bf79945","_cell_guid":"e07a4f35-c51e-4ec1-ba1c-294d5123d756"},"cell_type":"markdown","source":"# Piping hot data analysis: Using pipes in your analysis\n____\n\nIf you've looked at other people's R code, you may have noticed a strange symbol that looks like this:\n<center><font size=\"6\">%>%</font></center>\n\nThis symbol is called a \"pipe\" and is used to \"pipe\" the output of one function into another function. Like so:"},{"metadata":{"_uuid":"e59afcf7ecdd07c1ca3bda9b96427e829ae90684","trusted":false,"_cell_guid":"867cf2e8-91f9-4fe2-b5ba-d5a923ea3017"},"cell_type":"code","source":"c(1,2,5,5,10) %>% # concatenate these five numbers and then...\n    mean() %>% # get the mean and then...\n    prod(5) # multiply by five","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"024af9928ce37b8434349efb822ccd1ea6aa460a","trusted":false,"_cell_guid":"6d5e7f5c-c362-4185-9990-68272b5ebffc"},"cell_type":"code","source":"# this does the same thing as the above code, but is much harder to \n# read (and debug!)\nprod(mean(c(1,2,5,5,10)),5) ","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"19c3e45fd2557520577094afc7cba45b1337cbce","_cell_guid":"ad61e9cf-8af8-448a-a963-db97030b5fd5"},"cell_type":"markdown","source":"Note that pipes do not change the things you put into the pipes. Unless you re-assign the output of a set of piped operations to the same variable you fed into it, your inital variable won't be changed. "},{"metadata":{"_uuid":"10df07b35b11e4180505d886afb43ab30fd61b1c","trusted":false,"_cell_guid":"c74fd2ed-4acb-4afe-a71b-1acde11eec7e"},"cell_type":"code","source":"# save our vector to a test variable\nmyVariable <- \"some text\"\n\n# save a copy of our test variable\nmyVariable_beforePiping <- myVariable\n\n# do some piped operations\nmyVariable %>%\n    strsplit(split = \"\") %>% # split into characters\n    unlist() %>% # convert list to vector\n    sort() # alphabatize\n\n# check to make sure that our original variable hasn't changed\nidentical(myVariable, myVariable_beforePiping)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"f7c70b9c795a588774d67ab0c90c09c7342ae70f","_cell_guid":"c8324a35-a1c6-4df4-8d16-b8c2623d1620"},"cell_type":"markdown","source":"One thing to watch out for with pipes is that they will pass the output of whatever you're piping in as the *first* argument to the next function. "},{"metadata":{"_uuid":"f07274f85b1aab4aa10cad532c414200b97ddfd0","trusted":false,"_cell_guid":"e434d9d6-2b63-4cba-bc85-b5e7e0959e2c"},"cell_type":"code","source":"# for example the function round(x,n) rounds the values \n# of x to the nearest n decimal places\n\n# this will round the first number to two dicimal places,\n# *not* the second number to 3 decimal places\npiped <- 3.14152 %>%\n    round(1.5690)\n\npiped == round(3.14152, 1.5690) # the same as the above pipeline\npiped == round(1.5690, 3.14152) # different than the above pipelines","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"fd6529e15704332e895b0a3fe533d8cf38ac9409","_cell_guid":"98401566-9278-4bab-ad08-ba0d0621c7e4"},"cell_type":"markdown","source":"Piping is very helpful when we're working with a dataset because it lets us quickly apply several functions in order. For example, we may want to get a list of the names of all the columns in our data frame in alphabetical order. To do this we need to:\n\n* get the names of the columns in our data frame\n* sort them alphabetically\n\nWith pipes, we can do this in one call, but broken up over multiple lines where each line does exactly one thing. You can see that in the cell below.\n\n> **Do you have to have a new line after a %>%?** Nope! It's just convention that you have a new line that's indented after a %>%. It makes it a little easier to read, but it won't break your code if you don't do it."},{"metadata":{"_kg_hide-input":false,"_uuid":"106c1ccc5dcf6e2a60cadb0db8c4b5df2ae8724c","trusted":false,"_cell_guid":"741a728f-93b1-4cc4-b11e-aa9b137e93dd"},"cell_type":"code","source":"# get a list of all column names in alphabetic order \ncolumnsAlphaOrder <- farmData %>% # take farmData and...\n    names() %>% # get the column names and...\n    sort() # sort alphabetically\n\n# print the first six results\nhead(columnsAlphaOrder)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"18e96a73d15c78d3a34bc0973e137787f22f6de1","_cell_guid":"91b432a5-9241-4db8-b267-8b596eb36d7e"},"cell_type":"markdown","source":"Now that we've learned how to use pipes, we can use them to create seamless pipelines for manipulating data. First, however, why don't you get some practice with them in your workbook?\n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 2: Piping.\n\n____"},{"metadata":{"_uuid":"49914a0bb067f50a69df4edfeb12c5e4e32b5d13","_cell_guid":"9c5d2703-992e-45c1-808d-3f21c26e2304"},"cell_type":"markdown","source":"# Selecting specific columns \n____"},{"metadata":{"_uuid":"b6976218faa0399bd79c3c1f5fb9ad190f429e34","_cell_guid":"f4a19637-c742-4c53-ac16-cbd25f46a22d"},"cell_type":"markdown","source":"We can get the contents of specific columns by using the select() function. You pass the select() function the name of a column, and it will select and return just that column, like so:"},{"metadata":{"_uuid":"3a3e28d58d31a9aecffea7e524ed7ba6fa25c46e","trusted":false,"_cell_guid":"ea9e8a46-28f4-415b-ab5f-ebe9fc75ed3c"},"cell_type":"code","source":"farmData %>% # take the farmData dataset and...\n    select(gender1) %>% # select the column gender1 and...\n    head() # return the first six lines","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3574650d8d179637d264ab56c112835be0351f29","_cell_guid":"56865d64-30b2-4579-be12-ea5c43be8c31"},"cell_type":"markdown","source":"You can also use select() to remove a column, by passing it the name of the column you want to remove with the minus sign (-) in front of it."},{"metadata":{"_uuid":"4d57067b4731c86bf93f2d6f81252f7907dd9c56","trusted":false,"_cell_guid":"e067560e-053d-4fbf-83ae-854851e7a470"},"cell_type":"code","source":"farmData %>% # take the farmData data frame and...\n    select(-gender1) %>% # select every column *except* gender1 and...\n    head() # return just the first six lines","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"7e2a71f82d9e7d3e8c5fdcd1adf3d00dcfd9176b","_cell_guid":"199916dd-bbcb-4ab0-b371-b4117c30b377"},"cell_type":"markdown","source":"But it gets tedious to constantly type out a bunch of column names, and if we do it repeatedly we're likely to make mistakes. Thankfully, we can avoid this by passing a vector of column names to select() and it will grab all of those columns.\n\nTo make our lives easier, select() has a number of helper functions. One of them, starts_with(), lets us select all the columns whose names start with a certain text string. We can use that, for example, to get all the columns that start with “gender”."},{"metadata":{"_uuid":"4ab8bd33499b671fa5b85053d41c0a058784a3ee","trusted":false,"_cell_guid":"9eed9bde-1e86-4096-869b-e82f216034ff"},"cell_type":"code","source":"farmData %>% # take the farmData data frame and...\n    select(starts_with(\"gender\")) %>% # select every column that starts with \"gender\" and ...\n    head() # return just the first six lines","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5d915455ce7b3c447f6a9da5bcedb5e225930071","_cell_guid":"625e3c58-910e-420e-80eb-3746bb6f83fe"},"cell_type":"markdown","source":"We can also use starts_with() to select all columns that do *not* start with a certain text string by passing it to select with a minus sign (-) in front, like so:"},{"metadata":{"_uuid":"cf490f8b57401d35915b022366608e356378cfd3","trusted":false,"_cell_guid":"d5d49303-21ba-4ad1-a923-c41ed3d0a6ce"},"cell_type":"code","source":"farmData %>% # take the farmData data frame and...\n    select(-starts_with(\"gender\")) %>% # select all columns that don't start with \"gender\"...\n    head() # return just the first six lines","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"92a98b6ff1dd2364b0b44f2d6c9019a034b565d0","_cell_guid":"c4d606e4-f236-4192-85c2-02d64c6a7407"},"cell_type":"markdown","source":"As you can see, select() is a very powerful tool for getting specific columns out of your data frame. There are also [several other helper functions](https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/select_helpers) that make it easier to select specific columns, including:\n\n* ends_with(): Like starts_with, but looks at the end of each column name. \n* contains(): Looks for matches anywhere in the variable (\"some\" would match columns called \"handsome\", \"something\" and \"xX_some_otherText\")\n* one_of(...): Looks for columns that match one of the items in a character vector you pass into it. So if you were looking for the columns A, B and C, you could use one_of(c(\"A\", \"B\", \"C\")) to get those columns.\n\nYou can find additional information on the select() function [in the documentation](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf). \n\nSelect() is great, but it only gets us specific columns. What if you're interested in specific *rows* instead? For that, we need to turn to a new function: filter(). First, though, why don't you try your hand at using filter() yourself?"},{"metadata":{"_uuid":"4dbd164774ee765ca5fc34b9b7a4be2e8bef43f9","_cell_guid":"abad2b73-bdfa-498f-97ce-54f23bfdeac5"},"cell_type":"markdown","source":"___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 3: Selecting specific columns.\n\n____"},{"metadata":{"_uuid":"d073fd86b67ed660339b15f32db9363d347aa396","_cell_guid":"e051940f-8f99-4467-91b6-033668b6c0dc"},"cell_type":"markdown","source":"# Get Specific Rows With Filter\n___"},{"metadata":{"_uuid":"b22d02143638b23d3437bcf0b83c34301e2c790b","_cell_guid":"e7e177b6-a201-420c-bd75-163ed1dd3b12"},"cell_type":"markdown","source":"In the last section, we explored using select() to pull out certain columns. But what if you're looking to get a specific row or set of rows?\n\nYou can select specific rows using the function filter(). Filter works a bit differently from select(), however. While all columns have names (read_csv() will add generic ones if you try to read in a .csv without any) tibbles don't have row names by default, and some subsetting operations will actually remove them. \n\nSo how do we get specific rows if they don't have names? To answer this, let's take a second to think about what it means for data to be tidy. (I know, I know, it's all pretty abstract, but bear with me.) Tidy data has:\n\n* One variable per column\n* One observation per row\n\nWhen you're looking at your data, you don't usually care about getting one particular observation based on its name. Instead, you're usually looking for some set of observations that have a specific value for a certain variable. For instance, you may be interested in:\n\n* All houses worth < 100,000 dollars\n* All water samples taken on a certain day\n* All the dogs of a certain breed\n\nGiven this, it makes sense to select observations based on the value observed for a specific variable To do this, we pass the function filter() a logical statement that will be true for some observations and false for others. The function filter() returns only those rows for which the logical statement evaluates to true. \n\nThat's all a little esoteric, so let's work with some examples. Let's imagine we're interested in looking at farms in a specific village, in this case Tikare. We can get only observations from Tikare by filtering based on the variable \"vname\" (short for village name) and asking for only those rows where it is exactly equal to “Tikare”.\n"},{"metadata":{"_uuid":"c8ebacfc09ffac193351a873a4935eb25531699c","trusted":false,"_cell_guid":"f2d40eaf-c657-4043-b35c-d5b1234f3937"},"cell_type":"code","source":"farmData %>% # take farmData and...\n    filter(vname == \"Tikare\") # return only the rows where the vname is Tikare","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5a8314c085225b74e684132f137947f31734efea","_cell_guid":"7c0039fe-b060-49df-9c18-5499e73e59ac"},"cell_type":"markdown","source":"We might also be interested in getting all the farms that had 6 or more plots. We can do that using the greater than or equal to operator, which looks like this: >="},{"metadata":{"_uuid":"d9cad2031daecf3da1b66cef8e696a9194b79a11","trusted":false,"_cell_guid":"273ac6f9-8a56-4dec-9c5f-4fbbf216f56c"},"cell_type":"code","source":"# rows where the number of farm plots is great than or equal to 6\nfarmData %>% \n    filter(fplots >= 6)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"b8b7569742ed6eb87f693b302e1c912fda0714ac","_cell_guid":"35ea9535-2bf0-459b-a489-1117bf4a4448"},"cell_type":"markdown","source":"What logical operators can we use? The pretty straightforwards ones are these:\n\n* <  means \"less than\"\n* <= means \"less than or equal to\"\n* \\>\tmeans \"greater than\"\n* \\>= means \"greater than or equal to\"\n* == means \"exactly equal to\" (you can't use a single equal sign for this!)\n* != means \"not equal to\"\n\nYou can also connect logical statements using | and &:\n\n* x | y means \"x or y\"\n* x & y\tmeans \"x and y\"\n\nOne thing to watch for here is that for | and & you need both x and y to be logical. So if you're looking for results from either the village Tikare or the village Sefula the bit of code below will not work. While the left half is a logical vector (vname == \"Tikare\"), the right half is just a random string so | isn't sure what to do with it. \n"},{"metadata":{"_uuid":"3b662dada3e760af3e4de43ebe97b5018e8eba3b","trusted":false,"_cell_guid":"e4676e4d-8211-45ea-8dff-f2b6ecdb0f1a"},"cell_type":"code","source":"# this cell WILL NOT work\nfarmData %>% \n    filter(vname == \"Tikare\" | \"Sefula\")","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3c6176bc0282152559ebf20bde3171920125a9cd","_cell_guid":"b38be16c-df09-45eb-91c9-c2f8a3c8d1e4"},"cell_type":"markdown","source":"Instead, you need to make sure that you tell filter to look for rows where the variable vname is equal to Tikare or the variable vname is equal to Sefula, like so:"},{"metadata":{"_uuid":"9d9d1a9a26dce2657560616331c1b028ae8ad929","trusted":false,"_cell_guid":"3ef10b6f-c59f-4861-b7ea-77948861ad8b"},"cell_type":"code","source":"# get rows where the village is Tikare or Sefula\nfarmData %>% \n    filter(vname == \"Tikare\" | vname == \"Sefula\")","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"47e969eb4a453adbfb294090017988bf41a796d2","_cell_guid":"0cebbbc6-b4bc-42e6-a516-1dd5c8f4bd7b"},"cell_type":"markdown","source":"This is actually a very useful feature, because it means you can evaluate two different variables at the same time. For example, this will get you all the rows where the village is Bonanza *and* the farm has fewer than three plots."},{"metadata":{"_uuid":"2af2809cea6100bdf52ca32c4ebc0cc2bd2ccf13","trusted":false,"_cell_guid":"a680ee2f-49f4-413f-9d3f-b155e6ea6403"},"cell_type":"code","source":"# get rows where the village is Bonanza and there are less than three farm plots\nfarmData %>% \n    filter(vname == \"Bonanza\" & fplots < 3)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"e7125ba941b21f60be444ff35162880eb846e8ad","_cell_guid":"b61b03ca-6bdb-466c-af33-1a8fe37e3ec6"},"cell_type":"markdown","source":"So far we've learned:\n\n* how to use pipes (%>%)\n* how to get just the columns we want\n* how to get specific rows\n\nBut what if we want to add new columns that have new information in them? We'll get to that next, with mutate(). First however, it's time for you to get some practice with filter().\n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 4: Selecting specific rows.\n\n___"},{"metadata":{"_uuid":"8303d40efc76238ae684368bce374173afdd6f9d","_cell_guid":"e3428efd-64f9-4201-9e29-d5f7ac9c9e05"},"cell_type":"markdown","source":"# Add New Variables With Mutate\n___\n"},{"metadata":{"_uuid":"141879a7e98a22cd5e1ecfbfcb22ef272f99da1d","_cell_guid":"636193e3-2c15-4a59-89b4-99852de8a448"},"cell_type":"markdown","source":"One thing you will often want to do with datasets is to add new variables. For example, by looking at the documentation for this dataset, we can see that the variable \"tenure1\" in this dataset has information on whether the farmers currently working on a specific farm own it or not. It's been coded into six distinct variables:\n\n1. Own land and own use\n2. Own land and rent to others\n3. Sharecropped land\n4. Communal land (traditional ownership)\n5. Rented land\n6. Borrowed land (Do not pay for usage)\n\nWhat if we want to ask if there's a difference between land owners and non-land-owners? We will need to recode this variable to have more coarse-grained information. To do this, we can add a new variable, \"landowner\", using the mutate() function. \n\nHere we will set the value of \"landowner\" to TRUE if the variable tenure1 has the value of either 1 or 2 (which we can tell from the documentation are the values that indicate that a household owns land)."},{"metadata":{"_uuid":"ba95a14a8a953f460fe74b350a51252748804feb","trusted":false,"_cell_guid":"5b529695-1c66-4434-b216-8939c450c45c"},"cell_type":"code","source":"# add a variable for whether this household owns land\nfarmData <- farmData %>%\n    mutate(landowner = (tenure1 == 1 | tenure1 == 2)) \n\n# summerize just our new variable\nsummary(farmData$landowner)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"0d560d4ddc70dc38d6a0081757f8704ff5f3d5de","_cell_guid":"8b344e3d-85f7-47f1-9913-f22beb4f5394"},"cell_type":"markdown","source":"We can also add new variables we've calculated elsewhere using mutate(). For example, information on the gender of people in each household is spread across 39 separate columns (yikes!). We can get the count of the number of men and women in each household as a separate variable and then add that to our data frame. \n\nWe know, from looking at the documentation, that a value of \"1\" means that a person is a man and a value of \"2\" is a woman. To figure out the number of men, we can just count the number of times in each row that we see \"1\" in the columns that start with gender. Then we can do the same thing for \"2\" to count the number of women. "},{"metadata":{"_uuid":"dc8f0de409c05a77ed62a948be4fc2b18eaceea6","trusted":false,"_cell_guid":"04c14881-eb8d-4b60-95b0-04116f081dcc"},"cell_type":"code","source":"# get the number of men for each household\ncountOfMen <- farmData %>% \n    select(starts_with(\"gender\")) %>% # get only the columns with gender information\n    magrittr::equals(1) %>% # look at the whole dataframe to see if each cell has \"1\" in it\n    rowSums(na.rm = T) # count the number of times when this is true, by row\n\n# get the nubmber of women for each household\ncountOfWomen <- farmData %>% \n    select(starts_with(\"gender\")) %>% \n    magrittr::equals(2) %>%\n    rowSums(na.rm = T)\n\n# add these columns to our dataframe\nfarmData <- farmData %>% \n    mutate(men = countOfMen, women = countOfWomen) # add our new variables","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"51f1343165ead17d634381cb86aebf9edfac65d9","_cell_guid":"c4e6fcbc-89d6-4b9d-bb1c-ec34459da3de"},"cell_type":"markdown","source":"> **What's up with magrittr::equals()?** This lets me use the function equals() from the magrittr package without loading in the whole package, which I want to avoid because it conflicts with other parts of the tidyverse. It will only work if the package you're trying to get a function from is installed. (Fortunately, Kaggle has us covered here since they've got all of CRAN already installed.)\n\nThen we can use these new variables to add a new variable to our data frame with the total number of women and men per household in it."},{"metadata":{"scrolled":true,"_uuid":"bbc1e39052dca905054ebd7e197504feefb9687d","trusted":false,"_cell_guid":"c6d21db8-90e8-4ae3-a9ab-4ed447bf0ce7"},"cell_type":"code","source":"# add a new column with the total number of men + women\nfarmData <- farmData %>%\n    mutate(menPlusWomen = men + women)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"9bad0d353df4cc1724443fa28f091305f11d0630","_cell_guid":"43fd3b8c-2868-47fe-a28e-de6f74949171"},"cell_type":"markdown","source":"We can also check for how many farms the reported household size (hhsize) is the same as the number of men plus the number of women."},{"metadata":{"_uuid":"e2a3a021a6622ef7d19a7bff94b179b924ba42c7","trusted":false,"_cell_guid":"eb1f34f5-ec06-484a-a893-9ea50c1fd265"},"cell_type":"code","source":"# check to see how many households have a reported household size different from\n# the number of men & women who reported their gender\n(farmData$hhsize == farmData$menPlusWomen) %>%\n    na.omit() %>%\n    table()","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3a0d5d8b9afdef9e7702d46142edb6264ed8668b","_cell_guid":"b01a45df-d633-41a0-a373-008d3d3869fd"},"cell_type":"markdown","source":"So it looks like for roughly 20% of households there was a difference between the reported household size and the number of men plus the number of women. In the next section, we'll take a closer look at the biggest and smallest households and see if that will tell us anything about why we might have this imbalance. First, however, it's your turn to try your hand at mutating data. \n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 5: Creating new variables with mutate.\n\n___"},{"metadata":{"_uuid":"f02a205842b1a0c85b1c8206b3a4bc9d8a3c8779","_cell_guid":"dcefaf58-3111-4893-9f72-862f8f71d7d2"},"cell_type":"markdown","source":"# Reorder Data With Arrange\n____\n\nArrange() allows you to sort your data frame based on the value of a certain variable. This can be useful if you want to quickly see which measurements had the highest or lowest values.\n\nArrange() takes the name of the column you want to sort by. So this will sort by the total number of men plus women (the new variable we just created using mutate()). "},{"metadata":{"_uuid":"1b87d7896893c30c397b5d024e9f0c3d6c11f265","trusted":false,"_cell_guid":"30f8ff33-d99e-40e8-8b40-40fe819cd3a7"},"cell_type":"code","source":"farmData %>%\n    arrange(menPlusWomen) %>% # sort by the total number of men + women\n    head() # just return the first six rows","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"6b921fd6fefdcc667a373654d6146d5cf408f128","_cell_guid":"1584c238-2729-4fa6-ac20-73ffac7a8864"},"cell_type":"markdown","source":"Hmm, nothing jumps out so far. Let's look at the just the hhsize and menPlusWomen columns to see if there's anything that might explain the difference here. "},{"metadata":{"_uuid":"9805e6c12d33232fc73eb88931437b04d3122fdd","trusted":false,"_cell_guid":"759a49bc-cfc3-4847-886b-880339731947"},"cell_type":"code","source":"farmData %>%\n    select(menPlusWomen, hhsize) %>% # get just the menPlusWomen and hhsize columns\n    arrange(menPlusWomen) %>% # sort by the total number of men + women\n    head()","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"18a9d6f1ea683550da41f7b9277be2191c49050b","_cell_guid":"2b29b93c-14f6-46b4-b842-1ce2b50468a2"},"cell_type":"markdown","source":"Aha! It looks like gender wasn't recorded at all for some households, which would help explain the differences between the two datasets. (It's also possible that a binary male/female distinction may not be the best way to account for some individuals in these households.) How can we tell if that was the case for very large households as well as very small households? \n\nYou may have noticed that this is ascending order (from lower to higher) by default. You can sort in descending order (from high to low) by using the desc() function."},{"metadata":{"_uuid":"e754564487af7d4dd6df809a7b9df9269dcf5e16","trusted":false,"_cell_guid":"bfbb9f22-ce9d-41cf-a5a2-092fa2851065"},"cell_type":"code","source":"farmData %>%\n    arrange(desc(menPlusWomen)) %>% # sort by the total number of men + women, descending\n    head() # just return the first six rows","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"7c24c5175a14a8141ed17a5d0407e2853ca7be81","_cell_guid":"a034cf60-b4b5-41b0-a9bd-92894e607113"},"cell_type":"markdown","source":"Knowing this, we can also check out just the very large households. "},{"metadata":{"_uuid":"aa17ac795b09982a061cec712dd43a30a046e65e","trusted":false,"_cell_guid":"0bd0428d-7065-4500-b16f-f75a80891a63"},"cell_type":"code","source":"farmData %>%\n    select(menPlusWomen, hhsize) %>% # get just the menPlusWomen and hhsize columns\n    arrange(desc(menPlusWomen)) %>% # sort by the total number of men + women, descending\n    head() # just return the first six rows","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"85a4c8fde9972eb4f25ec04030ab10da377cfd79","_cell_guid":"16ea5481-9593-478f-baf3-6d18f23c08db"},"cell_type":"markdown","source":"What about if we arrange the data frame by hhsize instead of the count of men plus women?"},{"metadata":{"_uuid":"1c78cc847210baae8e6f07c176179d7689d0031d","trusted":false,"_cell_guid":"de704cf5-21ef-4cea-8b9a-67dfbf2895d8"},"cell_type":"code","source":"farmData %>%\n    select(menPlusWomen, hhsize) %>% # get just the menPlusWomen and hhsize columns\n    arrange(hhsize) %>% # sort by the household size\n    head() # just return the first six rows","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"092e6cfb37fe63366ac321e2b14b169bafc22255","_cell_guid":"c5125a79-f182-4a1e-a630-572c41fcbbad"},"cell_type":"markdown","source":"Interesting. While the lowest value in menPlusWomen was 0, it looks like the lowest value of hhsize is actually 1. (Which makes sense; it's hard to have a household of zero people). To understand why this might be be, let's look at the tail of our sorted data instead of the head. "},{"metadata":{"_uuid":"930a119cd290945c57992207b92d4de33ed42e03","trusted":false,"_cell_guid":"85028f4c-0ed7-4bb6-ba0a-1f152a688bab"},"cell_type":"code","source":"farmData %>%\n    select(menPlusWomen, hhsize) %>% # get just the menPlusWomen and hhsize columns\n    arrange(hhsize) %>% # sort by the total number of men + women, descending\n    tail() # just return the last six rows","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"6306956da8d19aca7bf56061dfe1c06b2cea5d51","_cell_guid":"ca2de6aa-c697-4312-b5b2-49eeb378d20b"},"cell_type":"markdown","source":"Arrange() will always put NA values at the end of our dataframe, and by looking at the tail we can see that there are households which don't have a reported household size. Unsurprisingly, these households also don't have any men or any women reported in them.\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 6: Sorting data with arrange.\n\n___"},{"metadata":{"_uuid":"8e6d44e088cb85a7af367ad265d6b3dbc6b3bb24","_cell_guid":"068753e0-f9c1-4ba7-bd08-3faff942fc34"},"cell_type":"markdown","source":"# Summarize variables with summarize\n\n____\n\nWe've already covered a lot of ways of interacting with data, but so far we've just been shuffling our data around and adding things to it. We haven't really touched on one of the core parts of data analysis: summarizing data. In the Tidyverse, you summarize data using the handily-named summarize() function.\n\n> **summarize()** or **summarise()**? You can use either spelling! Most of the documentation uses the summarise() version because that's the standard spelling in New Zealand, which is where Hadley Wickham, one of the core Tidyverse developers, is from. \n\nSummarize takes in a data frame and outputs a new data frame containing one or more variables based a functions applied to columns from the original data frame. So if we wanted to quickly compare the mean values of hhsize and menPlusWomen, we can do it this way:"},{"metadata":{"_uuid":"3a0143066fbc8794df9d7e43e9fdcd3991d3607a","trusted":false,"_cell_guid":"2c077cf2-a9cf-4fd8-9632-158eb1996bee"},"cell_type":"code","source":"# get the mean household size, by two different estimations\nfarmData %>%\n    summarize(meanMenPlusWomen = mean(menPlusWomen), #summerize the mean of menPlusWomen\n             meanhhsize = mean(hhsize, na.rm = T)) #mean of hhsize (removing NA's)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"289618dcc8104f65a642e086c8a81397a0a54d79","_cell_guid":"ab9ecf2c-cb55-4683-9802-7afb9c58b42a"},"cell_type":"markdown","source":"Let's use this to figure out how many rows we don't have any information for. For menPlusWomen, that's rows where we have a 0, but for household size, that's rows with NA's."},{"metadata":{"scrolled":true,"_uuid":"2584780003e75ffd022af34771a9767b866887ee","trusted":false,"_cell_guid":"2cb5e05e-481a-4984-965f-e3d0ceb83cbb"},"cell_type":"code","source":"farmData %>%\n    summarize(missingMenPlusWomen = sum(menPlusWomen == 0),\n             missinghhsize = sum(is.na(hhsize)))","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"54971b7b4e536c389fce13ca28c61c5020610e3a","_cell_guid":"897f3cc8-83d8-46b4-8018-62c1bc936d94"},"cell_type":"markdown","source":"So based on this, it looks like there are more rows where we don't have gender information than where we don't have information on the size of the household. \n\nSummarize can sometimes be useful by itself, but it's even more useful when we use it to ask questions about differences between groups. To do that, though, we'll need to introduce ourselves to one final function: group_by(). First, though, it's time for you to practice with summarize.\n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 7: Summarizing variables with summarize.\n\n___"},{"metadata":{"_uuid":"64863782dfd16bbc0e434c7fdb822202d6b6e6fe","_cell_guid":"c1c16f19-568e-4dd9-be71-b1592702bb58"},"cell_type":"markdown","source":"# Analyze groups with group_by\n\n____\n\n\nAs I mentioned above, summarize is most powerful when it's paired with group_by(). Group_by() doesn't really do much to your data frame by itself. Instead, once you've grouped a data frame by a variable, any functions you apply that would be applied to the whole data frame are instead applied separately to each level of the grouping factor instead.\n\nLet's see what this look likes with an example. Earlier, I added a new variable with whether or not a household owned land. I want to use this variable to see if households that own land tend to have more plots to farm. "},{"metadata":{"_uuid":"1b808137654e8392f656f92b9d48253af4fbc812","trusted":false,"_cell_guid":"1dcd8f96-d10a-4773-98d1-07823f48b19f"},"cell_type":"code","source":"farmData %>% \n    group_by(landowner) %>% # group by whether the household owns land \n    summarize(plots = median(fplots, na.rm = T)) # median number of plots they farm","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"8395548567dd7f9f69298b73270a0f7949813961","_cell_guid":"e4e9c22a-613b-4bd5-804c-f96f2ccbf36e"},"cell_type":"raw","source":"So it looks like households that own land do, in fact, tend to farm more plots. We can also see how many plots households tend to farm by grouping by fplots and then using tally() to count the number of observations in each group."},{"metadata":{"_uuid":"9af6b8012fc1d0a892bdcd0b4ea6b97056b7a384","trusted":false,"_cell_guid":"f5e60c1c-6811-40f7-acec-0224804931c7"},"cell_type":"code","source":"farmData %>% \n    group_by(fplots) %>% # group by the # of plots \n    tally() # tally the number of observations in each group","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"3e226772f90b2db65db353604d2e8d8cfd352e31","_cell_guid":"6edd7088-1f98-49fc-9110-ccb19c5e8cbc"},"cell_type":"markdown","source":"We can also group by more than one variable at a time. So, for example, if we wanted to count how many times we saw each combination of \"landowner\" and \"fplots\", we can group by both of those variables and then use tally()."},{"metadata":{"_kg_hide-input":false,"_uuid":"3e4e007250bd28223f79a9d0b0dfc7c036729fcb","trusted":false,"_cell_guid":"b7a8d825-8932-4130-a279-f2f8d1b84e29"},"cell_type":"code","source":"farmData %>% \n    group_by(landowner, fplots) %>% # group by whether the household owns land \n    tally() %>% # tally the number of observations in both groups\n    na.omit() # remove NA's","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"5d80c9c8a8e71a3c4e5f5e879462078fada7c3a5","_cell_guid":"0de63645-565e-45ae-91a8-ff7ddaf1b7c6"},"cell_type":"markdown","source":"This combination of grouping and then applying other functions allows us to ask very complex questions quickly. For example, one of the columns in the data frame, \"interviewer\", records the ID of the interviewer who collected each questionnaire. We can quickly summarize which interviewers collected the most questionnaires."},{"metadata":{"_uuid":"d96b44838d0a7ce479c22ca027910909b9731704","trusted":false,"_cell_guid":"f8da031f-f742-4556-a129-57b04660b417"},"cell_type":"code","source":"# most common responses when asked about long term shifts in rainfall\nfarmData %>% \n    group_by(interviewer) %>% # group by the levels of interviewer\n    tally() %>% # count the number of times each levels of the factor is observed\n    filter(n > 50) %>% # omit interviewers with only one interview\n    arrange(desc(n)) # sort by how common responses are","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"b6e70b985f0b0f4b6e5d23bd0d46243d1ba44740","_cell_guid":"5dfb1e98-2a25-4ca2-8087-46a308f12d2c"},"cell_type":"markdown","source":"Or we can see how many adapatations to changes in climate households tend to make."},{"metadata":{"_uuid":"1ec2cebec0078a7559d1ded6f3d35ec9783a45fb","trusted":false,"_cell_guid":"dfee3719-9514-46c8-9e86-f661881c65ae"},"cell_type":"code","source":"# count the total number of climate change adapations by household\nadaptationsCount <- farmData %>%\n    select(contains(\"ad71\")) %>%\n    rowSums() \n\n# count of households by the number of adaptations they've made\nfarmData %>% \n    mutate(adaptations = adaptationsCount) %>%\n    group_by(adaptations) %>%\n    tally()","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"aeedbad1d7db2e34a28d2c70ba407d91c5132ffe","_cell_guid":"7697ef16-a3a0-451f-8d0e-6ae6e65520c4"},"cell_type":"markdown","source":"Or we can see if landowners tend to make more or fewer adaptations due to changes in climate."},{"metadata":{"_uuid":"44e2b76849cf1ba2974408ab3d08d351ea5017c4","trusted":false,"_cell_guid":"1a85e3ab-2042-48ea-ba69-6ccb7e047fec"},"cell_type":"code","source":"# do landowners make more or fewer adaptations?\nfarmData %>% \n    mutate(adaptations = adaptationsCount) %>% # add count of adaptations\n    group_by(landowner) %>% # group by whether a household owns land\n    summarize(numberOfAdaptations = mean(adaptations, na.rm = T)) # mean # of adaptations","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"230ece5eb1a965b9201aa7666612c0c91f865bbd","_cell_guid":"095634cb-7e16-4bb4-9b96-82453d7d58f4"},"cell_type":"markdown","source":"Group_by(), especially in combination with summarize(), is a very powerful tool for quickly analyzing large datasets. Don't take my word for it, though: go practice with it yourself!\n\n___\n\n## Your turn!\n\n[Head over to your workbook](https://www.kaggle.com/rtatman/manipulating-data-with-the-tidyverse-workbook) and follow the exercises in Section 8: Analyzing groups with group_by.\n___"},{"metadata":{"_uuid":"6711a9dce4b3654adf2a4947fe3b7cb5b10d64cc","_cell_guid":"0b806e9f-73e6-453e-afd6-0cc6a13ad3e7"},"cell_type":"markdown","source":"# Conclusion\n_____\n\nNice work, you've made it to the end of this tutorial on manipulating data with the Tidyverse! At this point, you know how to: \n\n* Use the pipe (**%>%**) to create a seamless workflow \n* Use **select()** to select one or more columns\n* Use **filter()** to select one or more rows\n* Use **mutate()** to add new variables\n* Use **arrange()** to change the order of rows\n* Use **summarize()** to convert a variable to a single value\n* Use **group_by()** to group sets of observations \n\nIn the next tutorial in this series, we're going to use these skills in data manipulation to create some seriously cool plots."}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","version":"3.4.2","name":"R","pygments_lexer":"r","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}